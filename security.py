# This module implements the keys-exchange between client and server
# The KEY generated by Diffie-Hellman Algorithm shall be used as
# a seed to generate the KEY and IV to AES encryption
#
# You'll need to install the PyCrypto module. Try this: pip install pycrypto
#
# Mateus-n00b
#
#
from Crypto.Cipher import AES
import random,json
import prime_generator

# Prime numbers
PRIME = range(2,30001)
prime_generator.prime_generator(PRIME,30001)

KEY_LEN = 16 # Key length (use multiples of 16)
PADDING = ' ' # padding character

# Server keys-exchange
def diffie_hellman_server(conn):
    TEMP = {}
    FOO = ''
    # ------------------------------------
    # Generating vars
    # My secret number
    a = random.randint(1,35535)
    # My prime number
    p = random.choice(PRIME)

    #My basestring
    g = random.randint(1,35535)
    # ------------------------------------
    # Wainting for requests
    TEMP = {'p':p,'base':g}
    while 1:
        msg = conn.recv(1024)
        if "NEGOCIATION" in msg:
            conn.send(json.dumps(TEMP))
            # print "Sending base and prime number..."
            break
    # Calculating A = g^a mod p
    A = (g**a)%p
    # Receiving B = g^a mod p
    msg = conn.recv(1024)
    FOO = json.loads(msg)

    # Calculating s = B^a mod p
    B = FOO['B']
    seed = (B ** a)%p

    #Sending my A = g^a mod p
    # print "Sending my g^a mod p"
    TEMP = {'A':A}
    conn.send(json.dumps(TEMP))

    # Key and IV
    return generate_AES_key(seed)

# Client keys-exchange
def diffie_hellman_client(sock):
    TEMP = ''
    DICT = {}

    sock.send('NEGOCIATION') # Initiates a keys-exchange

    msg = sock.recv(1024)
    TEMP = json.loads(msg)
    #-----------------------------------
    # Generating vars
    # My secret number
    a = random.randint(1,35535)
    # The prime number
    p = TEMP['p']

    # The base
    g = TEMP['base']

    #-----------------------------------
    # Calculating A = g^a mod p
    B = (int(g)**a)%int(p)
    DICT = {'B':B}

    # Sending my B = g^a mod p
    # print "Sending my g^a mod p"
    sock.send(json.dumps(DICT))

    # Receiving B = g^a mod p
    msg = sock.recv(1024)
    TEMP = json.loads(msg)
    A = TEMP['A']

    # Calculating s = A ^ a mod p
    seed = (A**a)%p

    # Generate the iv and key
    return generate_AES_key(seed)

# Generate AES key and IV using the output from Diffie-Hellman
def generate_AES_key(seed):
    random.seed(seed)   # Set the seed

    enc_key = str() #
    iv_aes = str()  #    encryption vars

    for i in xrange(KEY_LEN):
        enc_key += chr(random.randint(1,256)) # Generate the 16B (by default) key for AES

    random.seed(seed+KEY_LEN) # new seed
    for i in xrange(KEY_LEN):
        iv_aes += chr(random.randint(1,256))

    return enc_key,iv_aes

# encrypt messages using AES
def encrypt_msg(key,iv,msg):
    while len(msg)%16 != 0:  # Fix the msg by adding a padding char because AES is a block cipher
        msg+=PADDING

    aes = AES.new(key,AES.MODE_CBC,iv)
    return aes.encrypt(msg)

# decrypt messages encrypted with AES
def decrypt_msg(key,iv,cipher_txt):
        aes = AES.new(key,AES.MODE_CBC,iv)
        return aes.decrypt(cipher_txt)
